
# MariaDB DDL Scenarios: Creating Tables

This document provides several real-world scenarios for creating table structures using MariaDB's Data Definition Language (DDL). Each scenario includes the `CREATE TABLE` statement and a detailed breakdown of the attributes (columns), their data types, and their purpose.

---

## Scenario 1: User Accounts Table (`users`)

**Use-Case:** A fundamental table for any application that requires user authentication and management.

### SQL Statement
```sql
CREATE TABLE users (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(255) NOT NULL,
    password_hash CHAR(60) NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login DATETIME NULL,
    PRIMARY KEY (id),
    UNIQUE KEY uk_username (username),
    UNIQUE KEY uk_email (email)
) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### Attribute Breakdown

| Column Name     | Data Type         | Constraints & Purpose                                                                                                                               |
|-----------------|-------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| `id`            | `INT UNSIGNED`    | **Primary Key.** `UNSIGNED` ensures we can have over 4 billion positive values. `AUTO_INCREMENT` automatically generates a new unique ID for each user. |
| `username`      | `VARCHAR(50)`     | **Unique Identifier.** The name a user logs in with. `VARCHAR` is used for variable-length strings. It's `NOT NULL` and `UNIQUE`.                     |
| `email`         | `VARCHAR(255)`    | **Unique Email.** Used for communication and password resets. It must also be `NOT NULL` and `UNIQUE`.                                                |
| `password_hash` | `CHAR(60)`        | **Hashed Password.** `CHAR` is used for fixed-length strings. A length of 60 is standard for storing hashes generated by `BCRYPT`. **Never store plain-text passwords.** |
| `is_active`     | `BOOLEAN`         | **Status Flag.** A boolean (`TINYINT(1)` in MariaDB) to determine if a user account is enabled or disabled. `DEFAULT TRUE` makes new users active.    |
| `created_at`    | `TIMESTAMP`       | **Audit Trail.** Automatically records the exact moment a user account is created. Useful for tracking and reporting.                               |
| `last_login`    | `DATETIME`        | **Tracking.** Stores the date and time of the user's last login. It's `NULL` because a new user hasn't logged in yet. `DATETIME` is used over `TIMESTAMP` when you don't need automatic updates. |

---

## Scenario 2: E-Commerce Products Table (`products`)

**Use-Case:** A table to store product information for an online store, including pricing, inventory, and descriptions.

### SQL Statement
```sql
CREATE TABLE products (
    product_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    sku VARCHAR(100) NOT NULL,
    product_name VARCHAR(255) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) NOT NULL,
    stock_quantity INT UNSIGNED DEFAULT 0,
    category_id INT UNSIGNED,
    added_on DATETIME DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (product_id),
    UNIQUE KEY uk_sku (sku),
    INDEX idx_category (category_id)
) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### Attribute Breakdown

| Column Name        | Data Type          | Constraints & Purpose                                                                                                                            |
|--------------------|--------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| `product_id`       | `BIGINT UNSIGNED`  | **Primary Key.** `BIGINT` is used in case the store has a massive number of products (more than 4 billion).                                        |
| `sku`              | `VARCHAR(100)`     | **Stock Keeping Unit.** A unique internal identifier for the product. Essential for inventory management.                                        |
| `product_name`     | `VARCHAR(255)`     | **Display Name.** The customer-facing name of the product.                                                                                       |
| `description`      | `TEXT`             | **Detailed Information.** A long-form description of the product. `TEXT` is used for strings that may exceed 65,535 characters.                    |
| `price`            | `DECIMAL(10, 2)`   | **Monetary Value.** The `DECIMAL` type is crucial for financial data to avoid floating-point rounding errors. This stores values up to `99,999,999.99`. |
| `stock_quantity`   | `INT UNSIGNED`     | **Inventory Count.** The number of items currently in stock. `UNSIGNED` prevents negative values.                                                |
| `category_id`      | `INT UNSIGNED`     | **Foreign Key.** A reference to the primary key of a (separate) `categories` table. An `INDEX` is created on this column for faster joins.        |
| `added_on`         | `DATETIME`         | **Record Creation Time.** Records when the product was first added to the database.                                                              |

---

## Scenario 3: Blog Posts Table (`posts`)

**Use-Case:** A table to manage content for a blog or news site, including different publication statuses.

### SQL Statement
```sql
CREATE TABLE posts (
    post_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    author_id INT UNSIGNED NOT NULL,
    title VARCHAR(255) NOT NULL,
    slug VARCHAR(255) NOT NULL,
    content LONGTEXT,
    status ENUM('draft', 'published', 'archived', 'pending_review') DEFAULT 'draft',
    published_at DATETIME NULL,
    last_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (post_id),
    UNIQUE KEY uk_slug (slug),
    INDEX idx_author (author_id),
    FOREIGN KEY (author_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### Attribute Breakdown

| Column Name     | Data Type         | Constraints & Purpose                                                                                                                               |
|-----------------|-------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| `post_id`       | `BIGINT UNSIGNED` | **Primary Key.** Uniquely identifies each blog post.                                                                                                |
| `author_id`     | `INT UNSIGNED`    | **Foreign Key.** Links to the `id` in the `users` table. `ON DELETE CASCADE` means if the user is deleted, all their posts are also deleted.          |
| `title`         | `VARCHAR(255)`    | **Post Title.** The main heading of the article.                                                                                                    |
| `slug`          | `VARCHAR(255)`    | **URL-Friendly Identifier.** A unique, URL-safe version of the title (e.g., "hello-world"). Used for clean URLs and SEO.                              |
| `content`       | `LONGTEXT`        | **Article Body.** The full content of the post, which could be very long and include HTML. `LONGTEXT` can store up to 4GB of text.                   |
| `status`        | `ENUM`            | **Publication Status.** Restricts the value to a predefined list. `ENUM` is very efficient for storing one of a few possible string values.          |
| `published_at`  | `DATETIME`        | **Publication Date.** The date and time the post was made public. `NULL` if it's still a draft.                                                     |
| `last_modified` | `TIMESTAMP`       | **Automatic Update Timestamp.** This value is automatically updated to the current time whenever the row's data is changed. Perfect for "Last Updated" info. |

---

## Scenario 4: Event Logging Table (`audit_log`)

**Use-Case:** A table for logging important events or actions within an application for auditing, security, or debugging purposes.

### SQL Statement
```sql
CREATE TABLE audit_log (
    log_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    event_timestamp TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6),
    user_id INT UNSIGNED NULL,
    source_ip VARCHAR(45),
    event_type VARCHAR(50) NOT NULL,
    details JSON,
    PRIMARY KEY (log_id),
    INDEX idx_event_type (event_type),
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### Attribute Breakdown

| Column Name       | Data Type      | Constraints & Purpose                                                                                                                               |
|-------------------|----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| `log_id`          | `BIGINT`       | **Primary Key.** Log tables can grow extremely large, so `BIGINT` is a safe choice.                                                                 |
| `event_timestamp` | `TIMESTAMP(6)` | **High-Precision Time.** Records when the event occurred with microsecond precision, which is critical for sequencing events accurately.              |
| `user_id`         | `INT UNSIGNED` | **Actor.** The ID of the user who performed the action. Can be `NULL` for system-generated events (e.g., a CRON job).                                |
| `source_ip`       | `VARCHAR(45)`  | **Source IP Address.** Stores the IPv4 or IPv6 address where the request originated. Useful for security tracking.                                   |
| `event_type`      | `VARCHAR(50)`  | **Event Category.** A short string describing the event (e.g., `USER_LOGIN_FAIL`, `PRODUCT_UPDATED`). Indexed for fast filtering.                     |
| `details`         | `JSON`         | **Dynamic Data.** Stores variable, semi-structured data as a JSON object. Perfect for holding contextual information that doesn't fit a rigid schema. |

---

## Scenario 5: Student Information System (One-to-Many & Many-to-Many)

**Use-Case:** A set of tables for a university to manage student enrollments in different courses and subjects. This demonstrates both a simple one-to-many relationship (a student belongs to one course) and a many-to-many relationship (a student can enroll in many subjects, and a subject can have many students).

### Supporting Tables (`courses`, `subjects`)

First, we need the tables that `students` and `student_subjects` will reference.

```sql
-- A simple table for university courses
CREATE TABLE courses (
    course_id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    course_code VARCHAR(20) NOT NULL,
    course_name VARCHAR(255) NOT NULL,
    department VARCHAR(100),
    PRIMARY KEY (course_id),
    UNIQUE KEY uk_course_code (course_code)
) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- A simple table for subjects offered
CREATE TABLE subjects (
    subject_id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    subject_code VARCHAR(20) NOT NULL,
    subject_name VARCHAR(255) NOT NULL,
    credits TINYINT UNSIGNED DEFAULT 3,
    PRIMARY KEY (subject_id),
    UNIQUE KEY uk_subject_code (subject_code)
) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### Scenario 5a: Students Table (One-to-Many)

This table stores student details and links each student to a single course.

#### SQL Statement
```sql
CREATE TABLE students (
    student_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL,
    date_of_birth DATE NOT NULL,
    enrollment_date DATE NOT NULL,
    course_id INT UNSIGNED,
    PRIMARY KEY (student_id),
    UNIQUE KEY uk_email (email),
    FOREIGN KEY (course_id) REFERENCES courses(course_id) ON DELETE SET NULL
) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### Attribute Breakdown

| Column Name       | Data Type         | Constraints & Purpose                                                                                                                            |
|-------------------|-------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| `student_id`      | `BIGINT UNSIGNED` | **Primary Key.** Uniquely identifies each student.                                                                                               |
| `first_name`      | `VARCHAR(100)`    | **Personal Info.** The student's first name.                                                                                                     |
| `last_name`       | `VARCHAR(100)`    | **Personal Info.** The student's last name.                                                                                                      |
| `email`           | `VARCHAR(255)`    | **Contact Info.** The student's unique email address.                                                                                            |
| `date_of_birth`   | `DATE`            | **Personal Info.** Stores the student's birth date. The `DATE` type is efficient for storing year, month, and day.                                |
| `enrollment_date` | `DATE`            | **Academic Info.** The date the student officially enrolled.                                                                                     |
| `course_id`       | `INT UNSIGNED`    | **Foreign Key.** Links to the `courses` table. `ON DELETE SET NULL` means if a course is deleted, the student's `course_id` will become `NULL`. |

---

### Scenario 5b: Student Subjects Linking Table (Many-to-Many)

This is a **linking table** (or junction table). Its primary purpose is to connect the `students` and `subjects` tables, creating a many-to-many relationship.

#### SQL Statement
```sql
CREATE TABLE student_subjects (
    student_id BIGINT UNSIGNED NOT NULL,
    subject_id INT UNSIGNED NOT NULL,
    enrollment_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    grade DECIMAL(5, 2) NULL,
    PRIMARY KEY (student_id, subject_id),
    FOREIGN KEY (student_id) REFERENCES students(student_id) ON DELETE CASCADE,
    FOREIGN KEY (subject_id) REFERENCES subjects(subject_id) ON DELETE CASCADE
) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### Attribute Breakdown

| Column Name            | Data Type         | Constraints & Purpose                                                                                                                                                           |
|------------------------|-------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `student_id`           | `BIGINT UNSIGNED` | **Composite Primary Key & Foreign Key.** Part of the primary key and a foreign key referencing `students`. `ON DELETE CASCADE` ensures that if a student is deleted, their enrollment records are also deleted. |
| `subject_id`           | `INT UNSIGNED`    | **Composite Primary Key & Foreign Key.** Part of the primary key and a foreign key referencing `subjects`. `ON DELETE CASCADE` ensures that if a subject is deleted, enrollment records for it are also deleted. |
| `enrollment_timestamp` | `TIMESTAMP`       | **Metadata.** Records the exact time a student enrolled in a subject.                                                                                                           |
| `grade`                | `DECIMAL(5, 2)`   | **Academic Record.** Stores the student's grade for the subject (e.g., 95.50). It is `NULL` until a grade is assigned.                                                          |

**Key Concept: Composite Primary Key**

The primary key `(student_id, subject_id)` is a **composite key**. It combines two columns to uniquely identify each row. This enforces the rule that a student can only be enrolled in the same subject once.

